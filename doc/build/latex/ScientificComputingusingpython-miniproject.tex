%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=49336sp\relax

\usepackage[margin=1in,marginparwidth=0.5in]{geometry}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}

\usepackage{multirow}
\usepackage{eqparbox}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing }}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{Scientific Computing using python - mini project Documentation}
\date{Jun 20, 2017}
\release{}
\author{Juan de Dios Flores Mendez}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{Indices and tables}
\label{\detokenize{index:welcome-to-scientific-computing-using-python-mini-project-s-documentation}}\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\chapter{Lorenz system}
\label{\detokenize{index:lorenz-system}}
The Lorenz system is a system of ordinary differential equations first studied by Edward Lorenz. It has chaotic solutions for certain parameter values and initial conditions. The Lorenz attractor is a set of chaotic solutions of the Lorenz system which, when plotted, resemble a butterfly or figure eight.

The lorenz equations are as follows
\begin{equation*}
\begin{split}\frac{dx}{dt} = \sigma (y-x), \\
\frac{dy}{dt} = x(\rho - z) - y, \\
\frac{dz}{dt} = xy - \beta z\end{split}
\end{equation*}
In order to solve the differential equations it is necessary to implement a solver for the differential equations, for which the Euler approximation for first order differential equations is selected.

It is formulated as
\begin{equation*}
\begin{split}\frac{x_{n+1} - x_n}{t_d} = f(x,y,z) \\
x_{n+1} = f(x,y,z) \cdot t_d + x_n\end{split}
\end{equation*}
The same formulation is applied for the rest of the differential equations.

It should be noticed that the solution for a period of time of the lorenz attractor is very sensitive to initial conditions.


\chapter{Launching the test cases for different parameters}
\label{\detokenize{index:launching-the-test-cases-for-different-parameters}}
Locate the terminal/ipython in the folder of cases. When running the script it will plot the different solutions and save all the figures, data and solutions to pdf and a hdf5 file.

You can run the test case 1 as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{python} \PYG{n}{case1}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

And for test case 2

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{python} \PYG{n}{case2}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

and so on

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{python} \PYG{n}{case3}\PYG{o}{.}\PYG{n}{py}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{python} \PYG{n}{case4}\PYG{o}{.}\PYG{n}{py}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{python} \PYG{n}{case5}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}


\chapter{Testing the code}
\label{\detokenize{index:testing-the-code}}
Locate the terminal/ipython in the folder of test. You can run the tests and it will be compared to numpy ODE solver. It should be noticed that the more chaotic the system it will fail the test.

It was observed that the Euler solver carry delays to the solution than the ODE solver inside numpy.

To run the tests you can type

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{python} \PYG{n}{test}\PYG{o}{.}\PYG{n}{py}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{n}{FF}
\end{sphinxVerbatim}

It will pass the first three cases and fail the last two cases, which are compared to the ODE solver of numpy. The output of dots mean that the case passed the test and the last two Fs means that it failed the case.


\chapter{The Lorenz package}
\label{\detokenize{index:the-lorenz-package}}
The package consists of the following modules and functions


\section{The modules and functions in the lorenz package are listed here}
\label{\detokenize{Functions::doc}}\label{\detokenize{Functions:the-modules-and-functions-in-the-lorenz-package-are-listed-here}}

\subsection{Solver: lorenz attractor solver}
\label{\detokenize{Functions:solver-lorenz-attractor-solver}}

\subsubsection{Intro}
\label{\detokenize{Functions:intro}}
It includes a basic solver for the lorenz attractor.


\subsubsection{Functions}
\label{\detokenize{Functions:functions}}\label{\detokenize{Functions:module-lorenz.solver}}\index{lorenz.solver (module)}
This is the solver for the differential equations of Lorenz attractor.
\index{lorenz\_solver() (in module lorenz.solver)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Functions:lorenz.solver.lorenz_solver}}\pysiglinewithargsret{\sphinxcode{lorenz.solver.}\sphinxbfcode{lorenz\_solver}}{\emph{state}, \emph{parameters}, \emph{t\_d}}{}
Returns the array of x,y,z value after solving the ODE of the lorenz
attractor using the Euler approach.

INPUT:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{state}\PYG{p}{:}    \PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z} \PYG{n}{state}
\PYG{n}{parameters}\PYG{p}{:}    \PYG{n}{sigma}\PYG{p}{,} \PYG{n}{rho}\PYG{p}{,} \PYG{n}{beta} \PYG{n}{parameters}
\PYG{n}{t\PYGZus{}d}\PYG{p}{:}    \PYG{n}{the} \PYG{n}{time} \PYG{n}{step} \PYG{k}{for} \PYG{n}{the} \PYG{n}{discrete} \PYG{n}{integration}
\end{sphinxVerbatim}

OUTPUT:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{x}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{y}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{z}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:}    \PYG{n}{The} \PYG{n+nb}{next} \PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z} \PYG{n}{values}
\end{sphinxVerbatim}

It is more accurate when it is close to the convergence point of the
attractor.

Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{state} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{parameters} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t\PYGZus{}d} \PYG{o}{=} \PYG{l+m+mf}{0.001}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{lorenz\PYGZus{}solver}\PYG{p}{(}\PYG{n}{state}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{n}{t\PYGZus{}d}\PYG{p}{)}
\PYG{g+go}{(1.0, 0.999, 1.0)}
\end{sphinxVerbatim}

\end{fulllineitems}



\subsubsection{Details}
\label{\detokenize{Functions:details}}
\sphinxstylestrong{Solver} .- It solves the differential equations with a first
order euler approach which explicit math is depicted below.
\begin{equation*}
\begin{split}[x_{n+1}, y_{n+1}, z_{n+1}] = [t_d \sigma  (y_n - x_n) + x_n, t_d  ( x_n  ( \rho - z_n) - y_n) + y_n, t_d (x_n y_n - \beta  z_n ) + z_n]\end{split}
\end{equation*}

\subsubsection{Code}
\label{\detokenize{Functions:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{This is the solver for the differential equations of Lorenz attractor. }
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k}{def} \PYG{n+nf}{lorenz\PYGZus{}solver}\PYG{p}{(}\PYG{n}{state}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{n}{t\PYGZus{}d}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    }
\PYG{l+s+sd}{    Returns the array of x,y,z value after solving the ODE of the lorenz}
\PYG{l+s+sd}{    attractor using the Euler approach. }

\PYG{l+s+sd}{    INPUT::}

\PYG{l+s+sd}{     state:    x,y,z state}
\PYG{l+s+sd}{     parameters:    sigma, rho, beta parameters}
\PYG{l+s+sd}{     t\PYGZus{}d:    the time step for the discrete integration}

\PYG{l+s+sd}{    OUTPUT::}

\PYG{l+s+sd}{     [x+1, y+1, z+1]:    The next x,y,z values}

\PYG{l+s+sd}{    It is more accurate when it is close to the convergence point of the}
\PYG{l+s+sd}{    attractor. }

\PYG{l+s+sd}{    Example: }

\PYG{l+s+sd}{    \PYGZgt{}\PYGZgt{}\PYGZgt{} state = [1.0, 1.0, 1.0]}
\PYG{l+s+sd}{    \PYGZgt{}\PYGZgt{}\PYGZgt{} parameters = [1.0, 1.0, 1.0]}
\PYG{l+s+sd}{    \PYGZgt{}\PYGZgt{}\PYGZgt{} t\PYGZus{}d = 0.001}
\PYG{l+s+sd}{    \PYGZgt{}\PYGZgt{}\PYGZgt{} lorenz\PYGZus{}solver(state, parameters, t\PYGZus{}d)}
\PYG{l+s+sd}{    (1.0, 0.999, 1.0)}
\PYG{l+s+sd}{    }
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z} \PYG{o}{=} \PYG{n}{state} \PYG{c+c1}{\PYGZsh{} get the state}
    \PYG{n}{sigma}\PYG{p}{,} \PYG{n}{rho}\PYG{p}{,} \PYG{n}{beta} \PYG{o}{=} \PYG{n}{parameters} \PYG{c+c1}{\PYGZsh{} get the parameters}
    \PYG{k}{return} \PYG{n}{t\PYGZus{}d} \PYG{o}{*} \PYG{n}{sigma} \PYG{o}{*} \PYG{p}{(}\PYG{n}{y} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{)} \PYG{o}{+} \PYG{n}{x}\PYG{p}{,} \PYG{n}{t\PYGZus{}d} \PYG{o}{*} \PYG{p}{(} \PYG{n}{x} \PYG{o}{*} \PYG{p}{(}\PYG{n}{rho} \PYG{o}{\PYGZhy{}} \PYG{n}{z}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)} \PYG{o}{+} \PYG{n}{y}\PYG{p}{,} \PYGZbs{}
           \PYG{n}{t\PYGZus{}d} \PYG{o}{*} \PYG{p}{(}\PYG{n}{x} \PYG{o}{*} \PYG{n}{y} \PYG{o}{\PYGZhy{}} \PYG{n}{beta} \PYG{o}{*} \PYG{n}{z} \PYG{p}{)} \PYG{o}{+} \PYG{n}{z}

\end{sphinxVerbatim}


\subsection{Plot: functions for plotting}
\label{\detokenize{Functions:plot-functions-for-plotting}}

\subsubsection{Functions}
\label{\detokenize{Functions:id1}}\phantomsection\label{\detokenize{Functions:module-lorenz.plot}}\index{lorenz.plot (module)}
This file may contain functionalities for plotting
\index{plot\_2d() (in module lorenz.plot)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Functions:lorenz.plot.plot_2d}}\pysiglinewithargsret{\sphinxcode{lorenz.plot.}\sphinxbfcode{plot\_2d}}{\emph{selection}, \emph{states}, \emph{save=False}, \emph{fname='experimental'}, \emph{directory=None}}{}
Plot the x,y and x,z and y,z coordinates of the lorenz attractor

INPUT:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{selection}\PYG{p}{:}    \PYG{n}{which} \PYG{n}{to} \PYG{n}{plot}
\PYG{n}{states}\PYG{p}{:}    \PYG{n}{array} \PYG{n}{of} \PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{]}
\PYG{n}{save}\PYG{p}{:}    \PYG{n+nb}{bool} \PYG{n}{value}
\PYG{n}{fname}\PYG{p}{:}    \PYG{n}{name} \PYG{n}{of} \PYG{n}{file}
\PYG{n}{directory}\PYG{p}{:} \PYG{n}{route} \PYG{o+ow}{or} \PYG{n}{name} \PYG{n}{of} \PYG{n}{folder}
\end{sphinxVerbatim}

OUTPUT:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Plots} \PYG{o+ow}{and} \PYG{n}{pdf} \PYG{n}{figures}
\end{sphinxVerbatim}

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plot\PYGZus{}2d}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{xy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{states}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{plot\_3d\_states() (in module lorenz.plot)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Functions:lorenz.plot.plot_3d_states}}\pysiglinewithargsret{\sphinxcode{lorenz.plot.}\sphinxbfcode{plot\_3d\_states}}{\emph{states}, \emph{save=False}, \emph{fname='experimental'}, \emph{directory=None}}{}
Plot the x,y,z coordinates of the lorenz attractor

INPUT:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{states}\PYG{p}{:}    \PYG{n}{array} \PYG{n}{of} \PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{]}
\PYG{n}{save}\PYG{p}{:}    \PYG{n+nb}{bool} \PYG{n}{value}
\PYG{n}{fname}\PYG{p}{:}    \PYG{n}{name} \PYG{n}{of} \PYG{n}{file}
\PYG{n}{directory}\PYG{p}{:} \PYG{n}{route} \PYG{o+ow}{or} \PYG{n}{name} \PYG{n}{of} \PYG{n}{folder}
\end{sphinxVerbatim}

OUTPUT:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Plots} \PYG{o+ow}{and} \PYG{n}{pdf} \PYG{n}{figures}
\end{sphinxVerbatim}

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plot\PYGZus{}3d\PYGZus{}states}\PYG{p}{(}\PYG{n}{states}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}



\subsubsection{Code}
\label{\detokenize{Functions:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{This file may contain functionalities for plotting}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{mpl\PYGZus{}toolkits}\PYG{n+nn}{.}\PYG{n+nn}{mplot3d} \PYG{k}{import} \PYG{n}{axes3d}\PYG{p}{,} \PYG{n}{Axes3D}

\PYG{k}{def} \PYG{n+nf}{plot\PYGZus{}3d\PYGZus{}states}\PYG{p}{(}\PYG{n}{states}\PYG{p}{,} \PYG{n}{save} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{fname} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{experimental}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
                   \PYG{n}{directory} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Plot the x,y,z coordinates of the lorenz attractor}

\PYG{l+s+sd}{    INPUT::}

\PYG{l+s+sd}{     states:    array of [x,y,z]}
\PYG{l+s+sd}{     save:    bool value}
\PYG{l+s+sd}{     fname:    name of file}
\PYG{l+s+sd}{     directory: route or name of folder}

\PYG{l+s+sd}{    OUTPUT:: }

\PYG{l+s+sd}{     Plots and pdf figures}

\PYG{l+s+sd}{    Example}

\PYG{l+s+sd}{    \PYGZgt{}\PYGZgt{}\PYGZgt{} plot\PYGZus{}3d\PYGZus{}states(states)}

\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{ax} \PYG{o}{=} \PYG{n}{Axes3D}\PYG{p}{(}\PYG{n}{fig}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}ax = fig.add\PYGZus{}subplot(111, projection=\PYGZsq{}3d\PYGZsq{})}
    \PYG{c+c1}{\PYGZsh{}ax = fig.gca(projection=\PYGZsq{}3d\PYGZsq{})}
    \PYG{c+c1}{\PYGZsh{}ax = fig.add\PYGZus{}subplot(111, projection = \PYGZsq{}3d\PYGZsq{})}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{states}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{states}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{states}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Lorenz Attractor}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}zlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{save}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{directory} \PYG{o}{!=} \PYG{k+kc}{None}\PYG{p}{:}
            \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{directory}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{os}\PYG{o}{.}\PYG{n}{makedirs}\PYG{p}{(}\PYG{n}{directory}\PYG{p}{)}
            \PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(} \PYG{n}{directory} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{fname} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}3d.pdf}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(} \PYG{n}{fname} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}3d.pdf}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{return}

\PYG{k}{def} \PYG{n+nf}{plot\PYGZus{}2d}\PYG{p}{(}\PYG{n}{selection}\PYG{p}{,} \PYG{n}{states}\PYG{p}{,} \PYG{n}{save} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{fname} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{experimental}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
            \PYG{n}{directory} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Plot the x,y and x,z and y,z coordinates of the lorenz attractor}

\PYG{l+s+sd}{    INPUT::}

\PYG{l+s+sd}{     selection:    which to plot}
\PYG{l+s+sd}{     states:    array of [x,y,z]}
\PYG{l+s+sd}{     save:    bool value}
\PYG{l+s+sd}{     fname:    name of file}
\PYG{l+s+sd}{     directory: route or name of folder}

\PYG{l+s+sd}{    OUTPUT:: }

\PYG{l+s+sd}{     Plots and pdf figures}

\PYG{l+s+sd}{    Example}

\PYG{l+s+sd}{    \PYGZgt{}\PYGZgt{}\PYGZgt{} plot\PYGZus{}2d(\PYGZdq{}xy\PYGZdq{}, states)}

\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{selection} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{xy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        PLot xy graph}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{states}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{states}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Lorenz Attractor XY}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{grid}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{save}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{directory} \PYG{o}{!=} \PYG{k+kc}{None}\PYG{p}{:}
                \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{directory}\PYG{p}{)}\PYG{p}{:}
                    \PYG{n}{os}\PYG{o}{.}\PYG{n}{makedirs}\PYG{p}{(}\PYG{n}{directory}\PYG{p}{)}
                \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(} \PYG{n}{directory} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{fname} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}xy.pdf}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{)}
            \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(} \PYG{n}{fname} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}xy.pdf}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{elif} \PYG{n}{selection} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{xz}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        Plot xz graph}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{states}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{states}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Lorenz Attractor XZ}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{grid}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{save}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{directory} \PYG{o}{!=} \PYG{k+kc}{None}\PYG{p}{:}
                \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{directory}\PYG{p}{)}\PYG{p}{:}
                    \PYG{n}{os}\PYG{o}{.}\PYG{n}{makedirs}\PYG{p}{(}\PYG{n}{directory}\PYG{p}{)}
                \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(} \PYG{n}{directory} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{fname} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}xz.pdf}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{)}
            \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(} \PYG{n}{fname} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}xz.pdf}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{elif} \PYG{n}{selection} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yz}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
        \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        Plot yz graph}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{states}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{states}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Lorenz Attractor YZ}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{grid}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{save}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{directory} \PYG{o}{!=} \PYG{k+kc}{None}\PYG{p}{:}
                \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{directory}\PYG{p}{)}\PYG{p}{:}
                    \PYG{n}{os}\PYG{o}{.}\PYG{n}{makedirs}\PYG{p}{(}\PYG{n}{directory}\PYG{p}{)}
                \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(} \PYG{n}{directory} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{fname} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}yz.pdf}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{)}
            \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(} \PYG{n}{fname} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}yz.pdf}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n+nb}{print} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The selection was not correct}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{return}
\end{sphinxVerbatim}


\subsection{File Handling: File handling for saving data for reproducible research}
\label{\detokenize{Functions:file-handling-file-handling-for-saving-data-for-reproducible-research}}

\subsubsection{Functions}
\label{\detokenize{Functions:id3}}\phantomsection\label{\detokenize{Functions:module-lorenz.filehandling}}\index{lorenz.filehandling (module)}
This file can contain functionalities for saving/loading data
\index{load\_all() (in module lorenz.filehandling)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Functions:lorenz.filehandling.load_all}}\pysiglinewithargsret{\sphinxcode{lorenz.filehandling.}\sphinxbfcode{load\_all}}{\emph{fname}}{}
Save the variables, parameters and results in a hdf5 file

INPUT:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fname}\PYG{p}{:}    \PYG{n}{name} \PYG{n}{of} \PYG{n}{file}
\end{sphinxVerbatim}

OUTPUT:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sigma}\PYG{p}{:}    \PYG{n}{sigma} \PYG{n}{parameter}
\PYG{n}{rho}\PYG{p}{:}    \PYG{n}{rho} \PYG{n}{parameter}
\PYG{n}{beta}\PYG{p}{:}    \PYG{n}{beta} \PYG{n}{parameter}
\PYG{n}{x}\PYG{p}{:}    \PYG{n}{x} \PYG{n}{initial} \PYG{n}{state}
\PYG{n}{y}\PYG{p}{:}    \PYG{n}{y} \PYG{n}{initial} \PYG{n}{state}
\PYG{n}{z}\PYG{p}{:}    \PYG{n}{z} \PYG{n}{initial} \PYG{n}{state}
\PYG{n}{t\PYGZus{}d}\PYG{p}{:}    \PYG{n}{time} \PYG{n}{differential}
\PYG{n}{N}\PYG{p}{:}    \PYG{n}{number} \PYG{n}{of} \PYG{n}{samples}
\PYG{n}{states}\PYG{p}{:}    \PYG{n}{array} \PYG{n}{of} \PYG{n}{states}
\end{sphinxVerbatim}

Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fname} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{experimental}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{[}\PYG{n}{sigma}\PYG{p}{,} \PYG{n}{rho}\PYG{p}{,} \PYG{n}{beta}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{n}{t\PYGZus{}d}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{states}\PYG{p}{]} \PYG{o}{=} \PYG{n}{load\PYGZus{}all}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{fulllineitems}

\index{save\_all() (in module lorenz.filehandling)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Functions:lorenz.filehandling.save_all}}\pysiglinewithargsret{\sphinxcode{lorenz.filehandling.}\sphinxbfcode{save\_all}}{\emph{fname}, \emph{sigma}, \emph{rho}, \emph{beta}, \emph{x}, \emph{y}, \emph{z}, \emph{t\_d}, \emph{N}, \emph{states}, \emph{directory=None}}{}
Save the variables, parameters and results in a hdf5 file

INPUT:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fname}\PYG{p}{:}    \PYG{n}{name} \PYG{n}{of} \PYG{n}{file} 
\PYG{n}{sigma}\PYG{p}{:}    \PYG{n}{sigma} \PYG{n}{parameter}
\PYG{n}{rho}\PYG{p}{:}    \PYG{n}{rho} \PYG{n}{parameter}
\PYG{n}{beta}\PYG{p}{:}    \PYG{n}{beta} \PYG{n}{parameter}
\PYG{n}{x}\PYG{p}{:}    \PYG{n}{x} \PYG{n}{initial} \PYG{n}{state}
\PYG{n}{y}\PYG{p}{:}    \PYG{n}{y} \PYG{n}{initial} \PYG{n}{state}
\PYG{n}{z}\PYG{p}{:}    \PYG{n}{z} \PYG{n}{initial} \PYG{n}{state}
\PYG{n}{t\PYGZus{}d}\PYG{p}{:}    \PYG{n}{time} \PYG{n}{differential}
\PYG{n}{N}\PYG{p}{:}    \PYG{n}{number} \PYG{n}{of} \PYG{n}{samples}
\PYG{n}{states}\PYG{p}{:}    \PYG{n}{array} \PYG{n}{of} \PYG{n}{states}
\PYG{n}{directory}\PYG{p}{:}    \PYG{n}{directory} \PYG{k}{for} \PYG{n}{saving}
\end{sphinxVerbatim}

OUTPUT:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{n}{file} \PYG{k}{with} \PYG{n+nb}{all} \PYG{n}{the} \PYG{n}{variables} \PYG{o+ow}{in} \PYG{n}{it}\PYG{o}{.} 
\end{sphinxVerbatim}

Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{save\PYGZus{}all}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{,} \PYG{n}{rho}\PYG{p}{,} \PYG{n}{beta}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{n}{t\PYGZus{}d}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{states}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{fulllineitems}



\subsubsection{Code}
\label{\detokenize{Functions:id4}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{This file can contain functionalities for saving/loading data}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k+kn}{import} \PYG{n+nn}{h5py}\PYG{o}{,} \PYG{n+nn}{os}

\PYG{k}{def} \PYG{n+nf}{save\PYGZus{}all}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{,} \PYG{n}{rho}\PYG{p}{,} \PYG{n}{beta}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{n}{t\PYGZus{}d}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{states}\PYG{p}{,} \PYG{n}{directory} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Save the variables, parameters and results in a hdf5 file}

\PYG{l+s+sd}{    INPUT:: }

\PYG{l+s+sd}{     fname:    name of file }
\PYG{l+s+sd}{     sigma:    sigma parameter}
\PYG{l+s+sd}{     rho:    rho parameter}
\PYG{l+s+sd}{     beta:    beta parameter}
\PYG{l+s+sd}{     x:    x initial state}
\PYG{l+s+sd}{     y:    y initial state}
\PYG{l+s+sd}{     z:    z initial state}
\PYG{l+s+sd}{     t\PYGZus{}d:    time differential}
\PYG{l+s+sd}{     N:    number of samples}
\PYG{l+s+sd}{     states:    array of states}
\PYG{l+s+sd}{     directory:    directory for saving}

\PYG{l+s+sd}{    OUTPUT::}

\PYG{l+s+sd}{     A file with all the variables in it. }

\PYG{l+s+sd}{    Example: }

\PYG{l+s+sd}{    \PYGZgt{}\PYGZgt{}\PYGZgt{} save\PYGZus{}all(fname, sigma, rho, beta, x, y, z, t\PYGZus{}d, N, states)  }
\PYG{l+s+sd}{     }
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{if} \PYG{n}{directory} \PYG{o}{!=} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{directory}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{os}\PYG{o}{.}\PYG{n}{makedirs}\PYG{p}{(}\PYG{n}{directory}\PYG{p}{)}
        \PYG{n}{f} \PYG{o}{=} \PYG{n}{h5py}\PYG{o}{.}\PYG{n}{File}\PYG{p}{(} \PYG{n}{directory} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{fname} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.hdf5}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{f} \PYG{o}{=} \PYG{n}{h5py}\PYG{o}{.}\PYG{n}{File}\PYG{p}{(} \PYG{n}{fname} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.hdf5}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        
    \PYG{n}{f}\PYG{o}{.}\PYG{n}{create\PYGZus{}dataset}\PYG{p}{(} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sigma}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{data} \PYG{o}{=} \PYG{n}{sigma}\PYG{p}{)}
    \PYG{n}{f}\PYG{o}{.}\PYG{n}{create\PYGZus{}dataset}\PYG{p}{(} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rho}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{data} \PYG{o}{=} \PYG{n}{rho}\PYG{p}{)}
    \PYG{n}{f}\PYG{o}{.}\PYG{n}{create\PYGZus{}dataset}\PYG{p}{(} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{beta}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{data} \PYG{o}{=} \PYG{n}{beta}\PYG{p}{)}
    \PYG{n}{f}\PYG{o}{.}\PYG{n}{create\PYGZus{}dataset}\PYG{p}{(} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{data} \PYG{o}{=} \PYG{n}{x}\PYG{p}{)}
    \PYG{n}{f}\PYG{o}{.}\PYG{n}{create\PYGZus{}dataset}\PYG{p}{(} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{data} \PYG{o}{=} \PYG{n}{y}\PYG{p}{)}
    \PYG{n}{f}\PYG{o}{.}\PYG{n}{create\PYGZus{}dataset}\PYG{p}{(} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{data} \PYG{o}{=} \PYG{n}{z}\PYG{p}{)}
    \PYG{n}{f}\PYG{o}{.}\PYG{n}{create\PYGZus{}dataset}\PYG{p}{(} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t\PYGZus{}d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{data} \PYG{o}{=} \PYG{n}{t\PYGZus{}d}\PYG{p}{)}
    \PYG{n}{f}\PYG{o}{.}\PYG{n}{create\PYGZus{}dataset}\PYG{p}{(} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{data} \PYG{o}{=} \PYG{n}{N}\PYG{p}{)}
    \PYG{n}{f}\PYG{o}{.}\PYG{n}{create\PYGZus{}dataset}\PYG{p}{(} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{states}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{data} \PYG{o}{=} \PYG{n}{states}\PYG{p}{)}
    \PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{load\PYGZus{}all}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    }
\PYG{l+s+sd}{    Save the variables, parameters and results in a hdf5 file}

\PYG{l+s+sd}{    INPUT:: }

\PYG{l+s+sd}{     fname:    name of file}

\PYG{l+s+sd}{    OUTPUT::}
\PYG{l+s+sd}{ }
\PYG{l+s+sd}{     sigma:    sigma parameter}
\PYG{l+s+sd}{     rho:    rho parameter}
\PYG{l+s+sd}{     beta:    beta parameter}
\PYG{l+s+sd}{     x:    x initial state}
\PYG{l+s+sd}{     y:    y initial state}
\PYG{l+s+sd}{     z:    z initial state}
\PYG{l+s+sd}{     t\PYGZus{}d:    time differential}
\PYG{l+s+sd}{     N:    number of samples}
\PYG{l+s+sd}{     states:    array of states}
\PYG{l+s+sd}{     }
\PYG{l+s+sd}{    Example: }

\PYG{l+s+sd}{    \PYGZgt{}\PYGZgt{}\PYGZgt{} fname = \PYGZdq{}experimental\PYGZdq{}}
\PYG{l+s+sd}{    \PYGZgt{}\PYGZgt{}\PYGZgt{} [sigma, rho, beta, x, y, z, t\PYGZus{}d, N, states] = load\PYGZus{}all(fname)  }
\PYG{l+s+sd}{     }
\PYG{l+s+sd}{    }
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{f} \PYG{o}{=} \PYG{n}{h5py}\PYG{o}{.}\PYG{n}{File}\PYG{p}{(} \PYG{n}{fname} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.hdf5}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{sigma} \PYG{o}{=} \PYG{n}{f} \PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sigma}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}
    \PYG{n}{sigma} \PYG{o}{=} \PYG{n}{sigma} \PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}
    \PYG{n}{rho} \PYG{o}{=} \PYG{n}{f} \PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rho}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}
    \PYG{n}{rho} \PYG{o}{=} \PYG{n}{rho} \PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}
    \PYG{n}{beta} \PYG{o}{=} \PYG{n}{f} \PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{beta}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}
    \PYG{n}{beta} \PYG{o}{=} \PYG{n}{beta} \PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{f} \PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{x} \PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{f} \PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{y} \PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}
    \PYG{n}{z} \PYG{o}{=} \PYG{n}{f} \PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}
    \PYG{n}{z} \PYG{o}{=} \PYG{n}{z} \PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}
    \PYG{n}{t\PYGZus{}d} \PYG{o}{=} \PYG{n}{f} \PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t\PYGZus{}d}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}
    \PYG{n}{t\PYGZus{}d} \PYG{o}{=} \PYG{n}{t\PYGZus{}d} \PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}
    \PYG{n}{N} \PYG{o}{=} \PYG{n}{f} \PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}
    \PYG{n}{N} \PYG{o}{=} \PYG{n}{N} \PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}
    \PYG{n}{states} \PYG{o}{=} \PYG{n}{f} \PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{states}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{]}
    \PYG{n}{states} \PYG{o}{=} \PYG{n}{states} \PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{sigma}\PYG{p}{,}\PYG{n}{rho}\PYG{p}{,}\PYG{n}{beta}\PYG{p}{,}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{t\PYGZus{}d}\PYG{p}{,}\PYG{n}{N}\PYG{p}{,}\PYG{n}{states}

   
\end{sphinxVerbatim}


\subsection{Run: Code for running all together}
\label{\detokenize{Functions:run-code-for-running-all-together}}

\subsubsection{Functions}
\label{\detokenize{Functions:id5}}\phantomsection\label{\detokenize{Functions:module-lorenz.run}}\index{lorenz.run (module)}
This file may contain a convenient interface/function for

1: computing a trajectory using an ODE solver from solver.py
2: save data to file
3: plot data
and possible another function that

2: load data from file
3: plot data
\index{load\_lorenz() (in module lorenz.run)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Functions:lorenz.run.load_lorenz}}\pysiglinewithargsret{\sphinxcode{lorenz.run.}\sphinxbfcode{load\_lorenz}}{\emph{fname='Test'}, \emph{plot=True}}{}
This function will load the lorenz and plot it

INPUT:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fname}\PYG{p}{:}    \PYG{n}{the} \PYG{n}{name} \PYG{n}{of} \PYG{n}{the} \PYG{n}{file} \PYG{n}{to} \PYG{n+nb}{open}
\PYG{n}{plot}\PYG{p}{:}    \PYG{n+nb}{bool} \PYG{n}{to} \PYG{n}{plot} \PYG{o+ow}{or} \PYG{o+ow}{not}
\end{sphinxVerbatim}

OUTPUT:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Nothing}\PYG{p}{,} \PYG{n}{just} \PYG{n}{plots}
\end{sphinxVerbatim}

Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{load\PYGZus{}lorenz}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Test}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{run\_lorenz() (in module lorenz.run)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Functions:lorenz.run.run_lorenz}}\pysiglinewithargsret{\sphinxcode{lorenz.run.}\sphinxbfcode{run\_lorenz}}{\emph{parameters, ini\_state={[}0.1, 0.1, 0.1{]}, t\_d=0.001, N=50000, plot=False, save=False, fname='Test', directory=None}}{}
Return the states, save the variables, plots and save the plots
using the auxiliary functions provided.

INPUT:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{parameters}\PYG{p}{:}    \PYG{n}{the} \PYG{n}{parameters} \PYG{n}{of} \PYG{n}{the} \PYG{n}{lorenz} \PYG{n}{attractor}
\PYG{n}{ini\PYGZus{}state}\PYG{p}{:}    \PYG{n}{initial} \PYG{n}{state} \PYG{n}{of} \PYG{n}{the} \PYG{n}{lorenz} \PYG{n}{attractor}
\PYG{n}{t\PYGZus{}d}\PYG{p}{:}    \PYG{n}{the} \PYG{n}{time} \PYG{n}{differential} 
\PYG{n}{N}\PYG{p}{:}    \PYG{n}{number} \PYG{n}{of} \PYG{n}{samples}
\PYG{n}{plot}\PYG{p}{:}    \PYG{n+nb}{bool} \PYG{n}{to} \PYG{n}{plot}
\PYG{n}{save}\PYG{p}{:}    \PYG{n+nb}{bool} \PYG{k}{for} \PYG{n}{saving}
\PYG{n}{fname}\PYG{p}{:}    \PYG{n}{name} \PYG{n}{of} \PYG{n}{file}
\PYG{n}{directory}\PYG{p}{:}    \PYG{n}{directory} \PYG{n}{to} \PYG{n}{save}
\end{sphinxVerbatim}

OUTPUT:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{states}\PYG{p}{:}    \PYG{n}{the} \PYG{n}{states} \PYG{n}{of} \PYG{n}{the} \PYG{n}{lorenz} \PYG{n}{attractor} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{span} \PYG{n}{of}
           \PYG{n}{the} \PYG{n}{differential} \PYG{n}{time} \PYG{o+ow}{and} \PYG{n}{number} \PYG{n}{of} \PYG{n}{samples}
\end{sphinxVerbatim}

Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{param} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{run\PYGZus{}lorenz}\PYG{p}{(}\PYG{n}{param}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}



\subsubsection{Code}
\label{\detokenize{Functions:id6}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{This file may contain a convenient interface/function for }

\PYG{l+s+sd}{1: computing a trajectory using an ODE solver from solver.py}
\PYG{l+s+sd}{2: save data to file}
\PYG{l+s+sd}{3: plot data}
\PYG{l+s+sd}{and possible another function that}

\PYG{l+s+sd}{2: load data from file}
\PYG{l+s+sd}{3: plot data}

\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{sys}\PYG{o}{,} \PYG{n+nn}{os}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{dirname}\PYG{p}{(}\PYG{n}{\PYGZus{}\PYGZus{}file\PYGZus{}\PYGZus{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{..}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}  
\PYG{k+kn}{import} \PYG{n+nn}{lorenz}\PYG{n+nn}{.}\PYG{n+nn}{plot} \PYG{k}{as} \PYG{n+nn}{pl}
\PYG{k+kn}{import} \PYG{n+nn}{lorenz}\PYG{n+nn}{.}\PYG{n+nn}{solver} \PYG{k}{as} \PYG{n+nn}{sol}
\PYG{k+kn}{import} \PYG{n+nn}{lorenz}\PYG{n+nn}{.}\PYG{n+nn}{filehandling} \PYG{k}{as} \PYG{n+nn}{fh}
\PYG{k+kn}{import} \PYG{n+nn}{lorenz}\PYG{n+nn}{.}\PYG{n+nn}{util} \PYG{k}{as} \PYG{n+nn}{ut}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}



\PYG{k}{def} \PYG{n+nf}{run\PYGZus{}lorenz}\PYG{p}{(}\PYG{n}{parameters}\PYG{p}{,} \PYG{n}{ini\PYGZus{}state} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{t\PYGZus{}d} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{n}{e}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} 
               \PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{50000}\PYG{p}{,} \PYG{n}{plot} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{save} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{fname} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Test}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
               \PYG{n}{directory} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Return the states, save the variables, plots and save the plots}
\PYG{l+s+sd}{    using the auxiliary functions provided. }

\PYG{l+s+sd}{    INPUT::}

\PYG{l+s+sd}{     parameters:    the parameters of the lorenz attractor}
\PYG{l+s+sd}{     ini\PYGZus{}state:    initial state of the lorenz attractor}
\PYG{l+s+sd}{     t\PYGZus{}d:    the time differential }
\PYG{l+s+sd}{     N:    number of samples}
\PYG{l+s+sd}{     plot:    bool to plot}
\PYG{l+s+sd}{     save:    bool for saving}
\PYG{l+s+sd}{     fname:    name of file}
\PYG{l+s+sd}{     directory:    directory to save}

\PYG{l+s+sd}{    OUTPUT:: }
\PYG{l+s+sd}{  }
\PYG{l+s+sd}{     states:    the states of the lorenz attractor in the span of}
\PYG{l+s+sd}{                the differential time and number of samples}

\PYG{l+s+sd}{    Example: }

\PYG{l+s+sd}{    \PYGZgt{}\PYGZgt{}\PYGZgt{} param = [10, 2, 6]}
\PYG{l+s+sd}{    \PYGZgt{}\PYGZgt{}\PYGZgt{} run\PYGZus{}lorenz(param)}
\PYG{l+s+sd}{     }
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{sigma}\PYG{p}{,} \PYG{n}{rho}\PYG{p}{,} \PYG{n}{beta} \PYG{o}{=} \PYG{n}{parameters}
    \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z} \PYG{o}{=} \PYG{n}{ini\PYGZus{}state}
    \PYG{c+c1}{\PYGZsh{}t\PYGZus{}d = t/N}
    \PYG{c+c1}{\PYGZsh{}time = [i*t\PYGZus{}d for i in range(N)] \PYGZsh{}get each discrete time}
    \PYG{n}{states} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}create the array}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{t\PYGZus{}d} \PYG{o}{*} \PYG{n}{N}
    \PYG{n}{ti} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{t\PYGZus{}d}\PYG{p}{)}
    \PYG{n}{cntr} \PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{ti}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:}
        \PYG{n}{states} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{concatenate}\PYG{p}{(}\PYG{p}{(}\PYG{n}{states}\PYG{p}{,} 
             \PYG{p}{[}\PYG{n}{sol}\PYG{o}{.}\PYG{n}{lorenz\PYGZus{}solver}\PYG{p}{(}\PYG{n}{states}\PYG{p}{[}\PYG{n}{cntr}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{n}{t\PYGZus{}d}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{cntr} \PYG{o}{=} \PYG{n}{cntr} \PYG{o}{+} \PYG{l+m+mi}{1}
        \PYG{c+c1}{\PYGZsh{}states = np.concatenate((states, }
        \PYG{c+c1}{\PYGZsh{}    [sol.lorenz\PYGZus{}solver(states[i\PYGZhy{}1,:], parameters, t\PYGZus{}d)]))}
    \PYG{k}{if} \PYG{n}{plot}\PYG{p}{:}
        \PYG{n}{pl}\PYG{o}{.}\PYG{n}{plot\PYGZus{}3d\PYGZus{}states}\PYG{p}{(}\PYG{n}{states}\PYG{p}{,} \PYG{n}{save}\PYG{p}{,} \PYG{n}{fname}\PYG{p}{,} \PYG{n}{directory}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}plot x,y,z}
        \PYG{n}{pl}\PYG{o}{.}\PYG{n}{plot\PYGZus{}2d}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{xy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{states}\PYG{p}{,} \PYG{n}{save}\PYG{p}{,} \PYG{n}{fname}\PYG{p}{,} \PYG{n}{directory}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}plot xy}
        \PYG{n}{pl}\PYG{o}{.}\PYG{n}{plot\PYGZus{}2d}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{xz}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{states}\PYG{p}{,} \PYG{n}{save}\PYG{p}{,} \PYG{n}{fname}\PYG{p}{,} \PYG{n}{directory}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}plot xz}
        \PYG{n}{pl}\PYG{o}{.}\PYG{n}{plot\PYGZus{}2d}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yz}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{states}\PYG{p}{,} \PYG{n}{save}\PYG{p}{,} \PYG{n}{fname}\PYG{p}{,} \PYG{n}{directory}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}plot yz}
    \PYG{k}{if} \PYG{n}{save}\PYG{p}{:}
        \PYG{n}{fh}\PYG{o}{.}\PYG{n}{save\PYGZus{}all}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{,} \PYG{n}{rho}\PYG{p}{,} \PYG{n}{beta}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{,} \PYG{n}{t\PYGZus{}d}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{states}\PYG{p}{,} 
                    \PYG{n}{directory}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{states}
         
\PYG{k}{def} \PYG{n+nf}{load\PYGZus{}lorenz}\PYG{p}{(}\PYG{n}{fname} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Test}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{plot} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    This function will load the lorenz and plot it}

\PYG{l+s+sd}{    INPUT:: }

\PYG{l+s+sd}{     fname:    the name of the file to open}
\PYG{l+s+sd}{     plot:    bool to plot or not}

\PYG{l+s+sd}{    OUTPUT:: }

\PYG{l+s+sd}{     Nothing, just plots}

\PYG{l+s+sd}{    Example: }

\PYG{l+s+sd}{    \PYGZgt{}\PYGZgt{}\PYGZgt{} load\PYGZus{}lorenz(\PYGZsq{}Test\PYGZsq{}, True)}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{p}{[}\PYG{n}{s2}\PYG{p}{,}\PYG{n}{r3}\PYG{p}{,}\PYG{n}{b2}\PYG{p}{,}\PYG{n}{x2}\PYG{p}{,}\PYG{n}{y2}\PYG{p}{,}\PYG{n}{z2}\PYG{p}{,}\PYG{n}{t\PYGZus{}d2}\PYG{p}{,}\PYG{n}{N2}\PYG{p}{,}\PYG{n}{st2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fh}\PYG{o}{.}\PYG{n}{load\PYGZus{}all}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{plot}\PYG{p}{:}
        \PYG{n}{pl}\PYG{o}{.}\PYG{n}{plot\PYGZus{}3d\PYGZus{}states}\PYG{p}{(}\PYG{n}{st2}\PYG{p}{)}
    \PYG{k}{return}
     
\PYG{k}{if} \PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    This is just debugging code}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{}print(\PYGZdq{}This is a convenient interface for running the simulation \PYGZbs{}}
\PYG{c+c1}{\PYGZsh{}     of a lorenz attractor\PYGZdq{})}
    \PYG{c+c1}{\PYGZsh{}sigma = ut.my\PYGZus{}input\PYGZus{}float(\PYGZdq{}sigma\PYGZdq{}) \PYGZsh{}input all parameters}
    \PYG{c+c1}{\PYGZsh{}rho = ut.my\PYGZus{}input\PYGZus{}float(\PYGZdq{}rho\PYGZdq{})}
    \PYG{c+c1}{\PYGZsh{}beta = ut.my\PYGZus{}input\PYGZus{}float(\PYGZdq{}beta\PYGZdq{})}
    \PYG{c+c1}{\PYGZsh{}x = ut.my\PYGZus{}input\PYGZus{}float(\PYGZdq{}x\PYGZdq{}) \PYGZsh{}input initial conditions}
    \PYG{c+c1}{\PYGZsh{}y = ut.my\PYGZus{}input\PYGZus{}float(\PYGZdq{}y\PYGZdq{})}
    \PYG{c+c1}{\PYGZsh{}z = ut.my\PYGZus{}input\PYGZus{}float(\PYGZdq{}z\PYGZdq{})}
    \PYG{c+c1}{\PYGZsh{}ini\PYGZus{}state = x, y, z}
    \PYG{n}{sigma} \PYG{o}{=} \PYG{l+m+mi}{10}
    \PYG{n}{rho} \PYG{o}{=} \PYG{l+m+mi}{6}
    \PYG{n}{beta} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{o}{/}\PYG{l+m+mi}{3}
    \PYG{n}{ini\PYGZus{}state} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{]}
    \PYG{n}{t\PYGZus{}d} \PYG{o}{=} \PYG{l+m+mf}{0.01}
    \PYG{c+c1}{\PYGZsh{}t = ut.my\PYGZus{}input\PYGZus{}int(\PYGZdq{}time in seconds\PYGZdq{}) }
    \PYG{n}{parameters} \PYG{o}{=} \PYG{p}{(}\PYG{n}{sigma}\PYG{p}{,} \PYG{n}{rho}\PYG{p}{,} \PYG{n}{beta}\PYG{p}{)}
    \PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{80000} \PYG{c+c1}{\PYGZsh{}assign 50000 steps as suggested}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{t\PYGZus{}d} \PYG{o}{*} \PYG{n}{N} \PYG{c+c1}{\PYGZsh{}timestep calculated from simulation time}
    \PYG{c+c1}{\PYGZsh{}states = np.array([[x,y,z]]) \PYGZsh{}create the array}
    \PYG{n}{states} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{ini\PYGZus{}state}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{N}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{states} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{concatenate}\PYG{p}{(}\PYG{p}{(}\PYG{n}{states}\PYG{p}{,} 
            \PYG{p}{[}\PYG{n}{sol}\PYG{o}{.}\PYG{n}{lorenz\PYGZus{}solver}\PYG{p}{(}\PYG{n}{states}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{n}{t\PYGZus{}d}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{pl}\PYG{o}{.}\PYG{n}{plot\PYGZus{}3d\PYGZus{}states}\PYG{p}{(}\PYG{n}{states}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}plot x,y,z}
    \PYG{c+c1}{\PYGZsh{}pl.plot\PYGZus{}2d(\PYGZdq{}xy\PYGZdq{}, states) \PYGZsh{}plot xy}
    \PYG{c+c1}{\PYGZsh{}pl.plot\PYGZus{}2d(\PYGZdq{}xz\PYGZdq{}, states) \PYGZsh{}plot xz}
    \PYG{c+c1}{\PYGZsh{}pl.plot\PYGZus{}2d(\PYGZdq{}yz\PYGZdq{}, states) \PYGZsh{}plot yz}

    \PYG{c+c1}{\PYGZsh{}fh.save\PYGZus{}all(\PYGZsq{}testo\PYGZsq{},sigma,rho,beta,x,y,z,t,t\PYGZus{}d,states)}
    \PYG{c+c1}{\PYGZsh{}[s2,r3,b2,x2,y2,z2,t2,t\PYGZus{}d2,st2] = fh.load\PYGZus{}all(\PYGZsq{}testo\PYGZsq{})}

    \PYG{c+c1}{\PYGZsh{}pl.plot\PYGZus{}3d\PYGZus{}states(st2)}
    
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    This is for testing. For testing the function. }
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{w\PYGZus{}states} \PYG{o}{=} \PYG{n}{ut}\PYG{o}{.}\PYG{n}{wikipedia\PYGZus{}lorenz}\PYG{p}{(}\PYG{p}{[}\PYG{n}{sigma}\PYG{p}{,} \PYG{n}{rho}\PYG{p}{,} \PYG{n}{beta}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ini\PYGZus{}state}\PYG{p}{,} \PYG{n}{t\PYGZus{}d}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{plot} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
    
    \PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{ax} \PYG{o}{=} \PYG{n}{fig}\PYG{o}{.}\PYG{n}{gca}\PYG{p}{(}\PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{w\PYGZus{}states}\PYG{p}{[}\PYG{l+m+mi}{0000}\PYG{p}{:}\PYG{l+m+mi}{70000}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{w\PYGZus{}states}\PYG{p}{[}\PYG{l+m+mi}{0000}\PYG{p}{:}\PYG{l+m+mi}{70000}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{w\PYGZus{}states}\PYG{p}{[}\PYG{l+m+mi}{0000}\PYG{p}{:}\PYG{l+m+mi}{70000}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{wiki}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Wikipedia}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
    
    \PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{ax} \PYG{o}{=} \PYG{n}{fig}\PYG{o}{.}\PYG{n}{gca}\PYG{p}{(}\PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{states}\PYG{p}{[}\PYG{l+m+mi}{0000}\PYG{p}{:}\PYG{l+m+mi}{70000}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{states}\PYG{p}{[}\PYG{l+m+mi}{0000}\PYG{p}{:}\PYG{l+m+mi}{70000}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{states}\PYG{p}{[}\PYG{l+m+mi}{0000}\PYG{p}{:}\PYG{l+m+mi}{70000}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{my}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ mine}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
    
    \PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{ax} \PYG{o}{=} \PYG{n}{fig}\PYG{o}{.}\PYG{n}{gca}\PYG{p}{(}\PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{states}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{states}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{states}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{w\PYGZus{}states}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{w\PYGZus{}states}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{w\PYGZus{}states}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{my}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{wiki}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Wikipedia vs mine}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
    
    
    \PYG{n}{ss} \PYG{o}{=} \PYG{n}{states} \PYG{o}{\PYGZhy{}} \PYG{n}{w\PYGZus{}states}
    \PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{ax} \PYG{o}{=} \PYG{n}{fig}\PYG{o}{.}\PYG{n}{gca}\PYG{p}{(}\PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{ss}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ss}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ss}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{my}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{diff Wikipedia vs mine}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}    }

\PYG{c+c1}{\PYGZsh{}    }
\PYG{c+c1}{\PYGZsh{}    import numpy as np}
\PYG{c+c1}{\PYGZsh{}    import matplotlib.pyplot as plt}
\PYG{c+c1}{\PYGZsh{}    from scipy.integrate import odeint}
\PYG{c+c1}{\PYGZsh{}    from mpl\PYGZus{}toolkits.mplot3d import Axes3D}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{}    rho = 28.0}
\PYG{c+c1}{\PYGZsh{}    sigma = 10.0}
\PYG{c+c1}{\PYGZsh{}    beta = 8.0 / 3.0}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{}    def f(state, t):}
\PYG{c+c1}{\PYGZsh{}        x, y, z = state  \PYGZsh{} unpack the state vector}
\PYG{c+c1}{\PYGZsh{}        return sigma * (y \PYGZhy{} x), x * (rho \PYGZhy{} z) \PYGZhy{} y, x * y \PYGZhy{} beta * z  \PYGZsh{} derivatives}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{}    state0 = [1.0, 1.0, 1.0]}
\PYG{c+c1}{\PYGZsh{}    t = np.arange(0.0, 40.0, 0.01)}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{}    states = odeint(f, state0, t)}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{}    fig = plt.figure()}
\PYG{c+c1}{\PYGZsh{}    ax = fig.gca(projection=\PYGZsq{}3d\PYGZsq{})}
\PYG{c+c1}{\PYGZsh{}    ax.plot(states[:,0], states[:,1], states[:,2])}
\PYG{c+c1}{\PYGZsh{}    plt.show()}
\end{sphinxVerbatim}


\subsection{Util: Utility code}
\label{\detokenize{Functions:util-utility-code}}

\subsubsection{Functions}
\label{\detokenize{Functions:id7}}\phantomsection\label{\detokenize{Functions:module-lorenz.util}}\index{lorenz.util (module)}
This file may contain utility functionalities.
\index{my\_input\_float() (in module lorenz.util)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Functions:lorenz.util.my_input_float}}\pysiglinewithargsret{\sphinxcode{lorenz.util.}\sphinxbfcode{my\_input\_float}}{\emph{var}}{}
This function is for validation of entering a float value.

INPUT:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{var}\PYG{p}{:}    \PYG{n}{name} \PYG{n}{of} \PYG{n}{variable} \PYG{n}{to} \PYG{n}{display}\PYG{o}{.} 
\end{sphinxVerbatim}

OUTPUT:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{variable}\PYG{p}{:}    \PYG{n+nb}{float} \PYG{n+nb}{input} \PYG{n}{variable}
\end{sphinxVerbatim}

Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{my\PYGZus{}input\PYGZus{}float}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{my\_input\_int() (in module lorenz.util)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Functions:lorenz.util.my_input_int}}\pysiglinewithargsret{\sphinxcode{lorenz.util.}\sphinxbfcode{my\_input\_int}}{\emph{var}}{}
This function is for validation of entering an int value.

INPUT:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{var}\PYG{p}{:}    \PYG{n}{name} \PYG{n}{of} \PYG{n}{variable} \PYG{n}{to} \PYG{n}{display}\PYG{o}{.} 
\end{sphinxVerbatim}

OUTPUT:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{variable}\PYG{p}{:}    \PYG{n+nb}{int} \PYG{n+nb}{input} \PYG{n}{variable}
\end{sphinxVerbatim}

Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{my\PYGZus{}input\PYGZus{}int}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{wikipedia\_lorenz() (in module lorenz.util)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Functions:lorenz.util.wikipedia_lorenz}}\pysiglinewithargsret{\sphinxcode{lorenz.util.}\sphinxbfcode{wikipedia\_lorenz}}{\emph{parameters, ini\_state={[}1.0, 1.0, 1.0{]}, t\_d=0.0008, N=50000, plot=False}}{}
This is a Lorenz attractor taken from the wikipedia page 
It will solve the lorenz attractor with a built-in solver
odeint of numpy

INPUT:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{parameters}\PYG{p}{:}    \PYG{n}{array} \PYG{n}{of} \PYG{n}{parameters} \PYG{n}{of} \PYG{n}{the} \PYG{n}{lorenz} \PYG{n}{attractor}
\PYG{n}{ini\PYGZus{}state}\PYG{p}{:}    \PYG{n}{initial} \PYG{n}{state}
\PYG{n}{t\PYGZus{}d}\PYG{p}{:}    \PYG{n}{time} \PYG{n}{difference}
\PYG{n}{N}\PYG{p}{:}    \PYG{n}{number} \PYG{n}{of} \PYG{n}{samples}
\PYG{n}{plot}\PYG{p}{:}    \PYG{n+nb}{bool} \PYG{n}{value} \PYG{k}{for} \PYG{n}{ploting}
\end{sphinxVerbatim}

OUTPUT:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{states}\PYG{p}{:}    \PYG{n}{array} \PYG{n}{of} \PYG{n}{states} 
\end{sphinxVerbatim}

Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{state} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{parameters} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{t\PYGZus{}d} \PYG{o}{=} \PYG{l+m+mf}{0.001}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{states} \PYG{o}{=} \PYG{n}{lorenz\PYGZus{}solver}\PYG{p}{(}\PYG{n}{parameters}\PYG{p}{,} \PYG{n}{state}\PYG{p}{,} \PYG{n}{t\PYGZus{}d}\PYG{p}{,} \PYG{n}{plot} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}



\subsubsection{Code}
\label{\detokenize{Functions:id8}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{This file may contain utility functionalities.}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{integrate} \PYG{k}{import} \PYG{n}{odeint}
\PYG{k+kn}{from} \PYG{n+nn}{mpl\PYGZus{}toolkits}\PYG{n+nn}{.}\PYG{n+nn}{mplot3d} \PYG{k}{import} \PYG{n}{Axes3D}

\PYG{k}{def} \PYG{n+nf}{my\PYGZus{}input\PYGZus{}float}\PYG{p}{(}\PYG{n}{var}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{l+s+sd}{    This function is for validation of entering a float value.}

\PYG{l+s+sd}{    INPUT::}

\PYG{l+s+sd}{     var:    name of variable to display. }

\PYG{l+s+sd}{    OUTPUT:: }

\PYG{l+s+sd}{     variable:    float input variable}

\PYG{l+s+sd}{    Example: }

\PYG{l+s+sd}{    \PYGZgt{}\PYGZgt{}\PYGZgt{} a = my\PYGZus{}input\PYGZus{}float(\PYGZdq{}a\PYGZdq{})}
\PYG{l+s+sd}{    }
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
        \PYG{k}{try}\PYG{p}{:}
            \PYG{n}{variable} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Please enter }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+} \PYG{n}{var} \PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{except} \PYG{n+ne}{ValueError}\PYG{p}{:}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sorry, I didn}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{t understand that.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
            \PYG{k}{continue}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{k}{break}
    \PYG{k}{return} \PYG{n}{variable}

\PYG{k}{def} \PYG{n+nf}{my\PYGZus{}input\PYGZus{}int}\PYG{p}{(}\PYG{n}{var}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{l+s+sd}{    This function is for validation of entering an int value.}

\PYG{l+s+sd}{    INPUT::}

\PYG{l+s+sd}{     var:    name of variable to display. }

\PYG{l+s+sd}{    OUTPUT:: }

\PYG{l+s+sd}{     variable:    int input variable}

\PYG{l+s+sd}{    Example: }

\PYG{l+s+sd}{    \PYGZgt{}\PYGZgt{}\PYGZgt{} a = my\PYGZus{}input\PYGZus{}int(\PYGZdq{}a\PYGZdq{})}
\PYG{l+s+sd}{    }
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
        \PYG{k}{try}\PYG{p}{:}
            \PYG{n}{variable} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Please enter }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+} \PYG{n}{var} \PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{except} \PYG{n+ne}{ValueError}\PYG{p}{:}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sorry, I didn}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{t understand that.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
            \PYG{k}{continue}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{k}{break}
    \PYG{k}{return} \PYG{n}{variable}

\PYG{k}{def} \PYG{n+nf}{wikipedia\PYGZus{}lorenz}\PYG{p}{(}\PYG{n}{parameters}\PYG{p}{,} \PYG{n}{ini\PYGZus{}state} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{,}
                     \PYG{n}{t\PYGZus{}d} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{n}{e}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{50000}\PYG{p}{,} \PYG{n}{plot} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    This is a Lorenz attractor taken from the wikipedia page }
\PYG{l+s+sd}{    It will solve the lorenz attractor with a built\PYGZhy{}in solver}
\PYG{l+s+sd}{    odeint of numpy}

\PYG{l+s+sd}{    INPUT:: }

\PYG{l+s+sd}{     parameters:    array of parameters of the lorenz attractor}
\PYG{l+s+sd}{     ini\PYGZus{}state:    initial state}
\PYG{l+s+sd}{     t\PYGZus{}d:    time difference}
\PYG{l+s+sd}{     N:    number of samples}
\PYG{l+s+sd}{     plot:    bool value for ploting}

\PYG{l+s+sd}{    OUTPUT:: }

\PYG{l+s+sd}{     states:    array of states }

\PYG{l+s+sd}{    Example:}

\PYG{l+s+sd}{    \PYGZgt{}\PYGZgt{}\PYGZgt{} state = [1.0, 1.0, 1.0]}
\PYG{l+s+sd}{    \PYGZgt{}\PYGZgt{}\PYGZgt{} parameters = [1.0, 1.0, 1.0]}
\PYG{l+s+sd}{    \PYGZgt{}\PYGZgt{}\PYGZgt{} t\PYGZus{}d = 0.001}
\PYG{l+s+sd}{    \PYGZgt{}\PYGZgt{}\PYGZgt{} states = lorenz\PYGZus{}solver(parameters, state, t\PYGZus{}d, plot = True)}
\PYG{l+s+sd}{     }
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{sigma}\PYG{p}{,} \PYG{n}{rho}\PYG{p}{,} \PYG{n}{beta} \PYG{o}{=} \PYG{n}{parameters}
    \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z} \PYG{o}{=} \PYG{n}{ini\PYGZus{}state}
    \PYG{c+c1}{\PYGZsh{}t\PYGZus{}d = t/N}

    \PYG{k}{def} \PYG{n+nf}{f}\PYG{p}{(}\PYG{n}{state}\PYG{p}{,} \PYG{n}{t}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z} \PYG{o}{=} \PYG{n}{state}  \PYG{c+c1}{\PYGZsh{} unpack the state vector}
        \PYG{k}{return} \PYG{n}{sigma} \PYG{o}{*} \PYG{p}{(}\PYG{n}{y} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{x} \PYG{o}{*} \PYG{p}{(}\PYG{n}{rho} \PYG{o}{\PYGZhy{}} \PYG{n}{z}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{,} \PYG{n}{x} \PYG{o}{*} \PYG{n}{y} \PYG{o}{\PYGZhy{}} \PYG{n}{beta} \PYG{o}{*} \PYG{n}{z}  \PYG{c+c1}{\PYGZsh{} derivatives}

    
    \PYG{n}{t\PYGZus{}t} \PYG{o}{=} \PYG{n}{t\PYGZus{}d} \PYG{o}{*} \PYG{n}{N}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{t\PYGZus{}t}\PYG{p}{,} \PYG{n}{t\PYGZus{}d}\PYG{p}{)}

    \PYG{n}{states} \PYG{o}{=} \PYG{n}{odeint}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{ini\PYGZus{}state}\PYG{p}{,} \PYG{n}{t}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{plot}\PYG{p}{:}
        \PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{ax} \PYG{o}{=} \PYG{n}{fig}\PYG{o}{.}\PYG{n}{gca}\PYG{p}{(}\PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{states}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{states}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{states}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Wikipedia Lorenz Attractor}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{states}
\end{sphinxVerbatim}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{l}
\item {\sphinxstyleindexentry{lorenz.filehandling}}\sphinxstyleindexpageref{Functions:\detokenize{module-lorenz.filehandling}}
\item {\sphinxstyleindexentry{lorenz.plot}}\sphinxstyleindexpageref{Functions:\detokenize{module-lorenz.plot}}
\item {\sphinxstyleindexentry{lorenz.run}}\sphinxstyleindexpageref{Functions:\detokenize{module-lorenz.run}}
\item {\sphinxstyleindexentry{lorenz.solver}}\sphinxstyleindexpageref{Functions:\detokenize{module-lorenz.solver}}
\item {\sphinxstyleindexentry{lorenz.util}}\sphinxstyleindexpageref{Functions:\detokenize{module-lorenz.util}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}